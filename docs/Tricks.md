This page contains a list of tips and tricks to be used when dealing with special scenarios with AutoFixture

## Random value from list of valid values

In case a certain type can assume a subset of the valid values, an instance of the `ElementsBuilder<T>` class can be used to provide AutoFixture with the values to fish from.

```csharp
[Test]
public void ElementsBuilder_returns_one_of_specified_values()
{
    // ARRANGE
    var fixture = new Fixture();
    var values = new[] { "Foo", "Bar", "Baz" };
    fixture.Customizations.Add(new ElementsBuilder<string>(values));

    // ACT
    var value = fixture.Create<string>();

    // ASSERT
    Assert.That(value, Is.AnyOf(values));
}
```

It's important to note that a setup like the one above affects every instance of the customized type: this means that every instance of the customized type generated by this fixture will be picked from the specified values.

### Random valid Encoding

By default, when requested an instance of type `Encoding`, AutoFixture always returns `Encoding.UTF8`.

It is possible to override the default setup by registering all supported encodings. To do so, we add an instance of `ElementsBuilder<EncodingInfo>` to the set of customizations. We can then use `Register` to instruct AutoFixture to extract an `Encoding` from the random `EncodingInfo` received.

```csharp
fixture.Customizations.Add(new ElementsBuilder<EncodingInfo>(Encoding.GetEncodings()));

fixture.Register<EncodingInfo, Encoding>((EncodingInfo ei) => ei.GetEncoding());
```

Furthermore, we can use the above configuration to configure the string property of an object that could be parsed from a text file.

```csharp
fixture.Customize<Options>(c => c.With(p => p.EncodingName, (Encoding encoding) => encoding.WebName));
```

Here is the class used for this example

```csharp
public class Options
{
    public string EncodingName { get; set; }
}
```

## Working with streams

Classes exposing properties of type `Stream` require special setup.

Here are some configurations that can be used when working with streams. The best setup might vary from case to case.

The following class will be used for the snippets below

```csharp
public class Options
{
    public Stream InputStream { get; set; }
}
```

### `NullStream`

The easiest scenario: every `Stream` property receives the singleton value of the `NullStream` class.

```csharp
fixture.Inject<Stream>(Stream.Null);
```

If a more targeted approach is needed, the construct `With` can be used.

```csharp
fixture.Customize<Options>(c => c.With(p => p.InputStream, Stream.Null));
```

### `MemoryStream`

In case the system under test expects some data out of the stream, the `MemoryStream` can be used to return the test data.

This setup will return a stream containing a certain amount of bytes. The amount is controlled by the `Fixture.RepeatCount` property.
```csharp
fixture.Register<byte[], Stream>((byte[] data) => new MemoryStream(data));
```

In the case the stream is expected to contain a random string, this setup can be used.

```csharp
fixture.Register<string, Stream>((string data) => 
{
	var bytes = Encoding.UTF8.GetBytes(data);
	return new MemoryStream(bytes);
});
```

Finally, if the stream is expected to contain the serialized version of some data, this setup can be used (the example uses Newtonsoft.Json to serialize the payload)

```csharp
fixture.Register<Data, Stream>((Data data) => 
{
	data.Dump();
	
	var serializer = new JsonSerializer();
	
	var ms = new MemoryStream();
	var sr = new StreamWriter(ms);
	
	serializer.Serialize(sr, data);
	
	sr.Flush();
	
	return ms;
});

public class Data
{
	public int Value { get; set; }
	
	public string Message { get; set; }
}
```

These setups can also be applied on a specific property of a specific type using the construct `With`.